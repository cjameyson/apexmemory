// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: assets.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const countFactsReferencingAsset = `-- name: CountFactsReferencingAsset :one
SELECT count(*) FROM app.facts
WHERE user_id = $1
  AND id != $2
  AND content->'asset_ids' @> $3::jsonb
`

type CountFactsReferencingAssetParams struct {
	UserID        uuid.UUID `json:"user_id"`
	ExcludeFactID uuid.UUID `json:"exclude_fact_id"`
	AssetIDJson   []byte    `json:"asset_id_json"`
}

func (q *Queries) CountFactsReferencingAsset(ctx context.Context, arg CountFactsReferencingAssetParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFactsReferencingAsset, arg.UserID, arg.ExcludeFactID, arg.AssetIDJson)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAsset = `-- name: CreateAsset :one
INSERT INTO app.assets (user_id, content_type, filename, size_bytes, sha256, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING user_id, id, content_type, filename, size_bytes, sha256, metadata, created_at, updated_at
`

type CreateAssetParams struct {
	UserID      uuid.UUID `json:"user_id"`
	ContentType string    `json:"content_type"`
	Filename    string    `json:"filename"`
	SizeBytes   int64     `json:"size_bytes"`
	Sha256      string    `json:"sha256"`
	Metadata    []byte    `json:"metadata"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, createAsset,
		arg.UserID,
		arg.ContentType,
		arg.Filename,
		arg.SizeBytes,
		arg.Sha256,
		arg.Metadata,
	)
	var i Asset
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.ContentType,
		&i.Filename,
		&i.SizeBytes,
		&i.Sha256,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAsset = `-- name: DeleteAsset :execrows
DELETE FROM app.assets
WHERE user_id = $1 AND id = $2
`

type DeleteAssetParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) DeleteAsset(ctx context.Context, arg DeleteAssetParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAsset, arg.UserID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteAssets = `-- name: DeleteAssets :execrows
DELETE FROM app.assets
WHERE user_id = $1 AND id = ANY($2::uuid[])
`

type DeleteAssetsParams struct {
	UserID uuid.UUID   `json:"user_id"`
	Ids    []uuid.UUID `json:"ids"`
}

func (q *Queries) DeleteAssets(ctx context.Context, arg DeleteAssetsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAssets, arg.UserID, arg.Ids)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAsset = `-- name: GetAsset :one
SELECT user_id, id, content_type, filename, size_bytes, sha256, metadata, created_at, updated_at FROM app.assets
WHERE user_id = $1 AND id = $2
`

type GetAssetParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) GetAsset(ctx context.Context, arg GetAssetParams) (Asset, error) {
	row := q.db.QueryRow(ctx, getAsset, arg.UserID, arg.ID)
	var i Asset
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.ContentType,
		&i.Filename,
		&i.SizeBytes,
		&i.Sha256,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
