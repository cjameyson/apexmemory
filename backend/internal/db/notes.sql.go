// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notes.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countNotesByNotebook = `-- name: CountNotesByNotebook :one
SELECT count(*) FROM app.notes
WHERE user_id = $1 AND notebook_id = $2
`

type CountNotesByNotebookParams struct {
	UserID     uuid.UUID `json:"user_id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) CountNotesByNotebook(ctx context.Context, arg CountNotesByNotebookParams) (int64, error) {
	row := q.db.QueryRow(ctx, countNotesByNotebook, arg.UserID, arg.NotebookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createNote = `-- name: CreateNote :one
INSERT INTO app.notes (user_id, notebook_id, note_type, content, source_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING user_id, id, notebook_id, note_type, content, source_id, created_at, updated_at
`

type CreateNoteParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	NoteType   string      `json:"note_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (Note, error) {
	row := q.db.QueryRow(ctx, createNote,
		arg.UserID,
		arg.NotebookID,
		arg.NoteType,
		arg.Content,
		arg.SourceID,
	)
	var i Note
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.NoteType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteNote = `-- name: DeleteNote :execrows
DELETE FROM app.notes
WHERE user_id = $1 AND id = $2 AND notebook_id = $3
`

type DeleteNoteParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) DeleteNote(ctx context.Context, arg DeleteNoteParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteNote, arg.UserID, arg.ID, arg.NotebookID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getNote = `-- name: GetNote :one
SELECT n.user_id, n.id, n.notebook_id, n.note_type, n.content, n.source_id, n.created_at, n.updated_at, (SELECT count(*) FROM app.cards c WHERE c.user_id = n.user_id AND c.note_id = n.id) AS card_count
FROM app.notes n
WHERE n.user_id = $1 AND n.id = $2 AND n.notebook_id = $3
`

type GetNoteParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

type GetNoteRow struct {
	UserID     uuid.UUID   `json:"user_id"`
	ID         uuid.UUID   `json:"id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	NoteType   string      `json:"note_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	CardCount  int64       `json:"card_count"`
}

func (q *Queries) GetNote(ctx context.Context, arg GetNoteParams) (GetNoteRow, error) {
	row := q.db.QueryRow(ctx, getNote, arg.UserID, arg.ID, arg.NotebookID)
	var i GetNoteRow
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.NoteType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const listNotesByNotebook = `-- name: ListNotesByNotebook :many
SELECT n.user_id, n.id, n.notebook_id, n.note_type, n.content, n.source_id, n.created_at, n.updated_at, (SELECT count(*) FROM app.cards c WHERE c.user_id = n.user_id AND c.note_id = n.id) AS card_count
FROM app.notes n
WHERE n.user_id = $1 AND n.notebook_id = $2
ORDER BY n.created_at DESC
LIMIT $4 OFFSET $3
`

type ListNotesByNotebookParams struct {
	UserID     uuid.UUID `json:"user_id"`
	NotebookID uuid.UUID `json:"notebook_id"`
	RowOffset  int32     `json:"row_offset"`
	RowLimit   int32     `json:"row_limit"`
}

type ListNotesByNotebookRow struct {
	UserID     uuid.UUID   `json:"user_id"`
	ID         uuid.UUID   `json:"id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	NoteType   string      `json:"note_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	CardCount  int64       `json:"card_count"`
}

func (q *Queries) ListNotesByNotebook(ctx context.Context, arg ListNotesByNotebookParams) ([]ListNotesByNotebookRow, error) {
	rows, err := q.db.Query(ctx, listNotesByNotebook,
		arg.UserID,
		arg.NotebookID,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListNotesByNotebookRow{}
	for rows.Next() {
		var i ListNotesByNotebookRow
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.NotebookID,
			&i.NoteType,
			&i.Content,
			&i.SourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNoteContent = `-- name: UpdateNoteContent :one
UPDATE app.notes
SET content = $1
WHERE user_id = $2 AND id = $3 AND notebook_id = $4
RETURNING user_id, id, notebook_id, note_type, content, source_id, created_at, updated_at
`

type UpdateNoteContentParams struct {
	Content    []byte    `json:"content"`
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) UpdateNoteContent(ctx context.Context, arg UpdateNoteContentParams) (Note, error) {
	row := q.db.QueryRow(ctx, updateNoteContent,
		arg.Content,
		arg.UserID,
		arg.ID,
		arg.NotebookID,
	)
	var i Note
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.NoteType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
