// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: facts.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countFactsByNotebook = `-- name: CountFactsByNotebook :one
SELECT count(*) FROM app.facts
WHERE user_id = $1 AND notebook_id = $2
`

type CountFactsByNotebookParams struct {
	UserID     uuid.UUID `json:"user_id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) CountFactsByNotebook(ctx context.Context, arg CountFactsByNotebookParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFactsByNotebook, arg.UserID, arg.NotebookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFact = `-- name: CreateFact :one
INSERT INTO app.facts (user_id, notebook_id, fact_type, content, source_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING user_id, id, notebook_id, fact_type, content, source_id, created_at, updated_at
`

type CreateFactParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	FactType   string      `json:"fact_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
}

func (q *Queries) CreateFact(ctx context.Context, arg CreateFactParams) (AppFact, error) {
	row := q.db.QueryRow(ctx, createFact,
		arg.UserID,
		arg.NotebookID,
		arg.FactType,
		arg.Content,
		arg.SourceID,
	)
	var i AppFact
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.FactType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFact = `-- name: DeleteFact :execrows
DELETE FROM app.facts
WHERE user_id = $1 AND id = $2 AND notebook_id = $3
`

type DeleteFactParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) DeleteFact(ctx context.Context, arg DeleteFactParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteFact, arg.UserID, arg.ID, arg.NotebookID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getFact = `-- name: GetFact :one
SELECT n.user_id, n.id, n.notebook_id, n.fact_type, n.content, n.source_id, n.created_at, n.updated_at, (SELECT count(*) FROM app.cards c WHERE c.user_id = n.user_id AND c.fact_id = n.id) AS card_count
FROM app.facts n
WHERE n.user_id = $1 AND n.id = $2 AND n.notebook_id = $3
`

type GetFactParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

type GetFactRow struct {
	UserID     uuid.UUID   `json:"user_id"`
	ID         uuid.UUID   `json:"id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	FactType   string      `json:"fact_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	CardCount  int64       `json:"card_count"`
}

func (q *Queries) GetFact(ctx context.Context, arg GetFactParams) (GetFactRow, error) {
	row := q.db.QueryRow(ctx, getFact, arg.UserID, arg.ID, arg.NotebookID)
	var i GetFactRow
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.FactType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CardCount,
	)
	return i, err
}

const listFactsByNotebook = `-- name: ListFactsByNotebook :many
SELECT n.user_id, n.id, n.notebook_id, n.fact_type, n.content, n.source_id, n.created_at, n.updated_at, (SELECT count(*) FROM app.cards c WHERE c.user_id = n.user_id AND c.fact_id = n.id) AS card_count
FROM app.facts n
WHERE n.user_id = $1 AND n.notebook_id = $2
ORDER BY n.created_at DESC
LIMIT $4 OFFSET $3
`

type ListFactsByNotebookParams struct {
	UserID     uuid.UUID `json:"user_id"`
	NotebookID uuid.UUID `json:"notebook_id"`
	RowOffset  int32     `json:"row_offset"`
	RowLimit   int32     `json:"row_limit"`
}

type ListFactsByNotebookRow struct {
	UserID     uuid.UUID   `json:"user_id"`
	ID         uuid.UUID   `json:"id"`
	NotebookID uuid.UUID   `json:"notebook_id"`
	FactType   string      `json:"fact_type"`
	Content    []byte      `json:"content"`
	SourceID   pgtype.UUID `json:"source_id"`
	CreatedAt  time.Time   `json:"created_at"`
	UpdatedAt  time.Time   `json:"updated_at"`
	CardCount  int64       `json:"card_count"`
}

func (q *Queries) ListFactsByNotebook(ctx context.Context, arg ListFactsByNotebookParams) ([]ListFactsByNotebookRow, error) {
	rows, err := q.db.Query(ctx, listFactsByNotebook,
		arg.UserID,
		arg.NotebookID,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFactsByNotebookRow{}
	for rows.Next() {
		var i ListFactsByNotebookRow
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.NotebookID,
			&i.FactType,
			&i.Content,
			&i.SourceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CardCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFactContent = `-- name: UpdateFactContent :one
UPDATE app.facts
SET content = $1
WHERE user_id = $2 AND id = $3 AND notebook_id = $4
RETURNING user_id, id, notebook_id, fact_type, content, source_id, created_at, updated_at
`

type UpdateFactContentParams struct {
	Content    []byte    `json:"content"`
	UserID     uuid.UUID `json:"user_id"`
	ID         uuid.UUID `json:"id"`
	NotebookID uuid.UUID `json:"notebook_id"`
}

func (q *Queries) UpdateFactContent(ctx context.Context, arg UpdateFactContentParams) (AppFact, error) {
	row := q.db.QueryRow(ctx, updateFactContent,
		arg.Content,
		arg.UserID,
		arg.ID,
		arg.NotebookID,
	)
	var i AppFact
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.FactType,
		&i.Content,
		&i.SourceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
