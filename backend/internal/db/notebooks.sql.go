// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: notebooks.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const archiveNotebook = `-- name: ArchiveNotebook :execrows
UPDATE app.notebooks
SET archived_at = now()
WHERE user_id = $1 AND id = $2 AND archived_at IS NULL
`

type ArchiveNotebookParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) ArchiveNotebook(ctx context.Context, arg ArchiveNotebookParams) (int64, error) {
	result, err := q.db.Exec(ctx, archiveNotebook, arg.UserID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const createNotebook = `-- name: CreateNotebook :one
INSERT INTO app.notebooks (user_id, name, description, emoji, color, position, fsrs_settings)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    COALESCE($6, 0),
    $7
)
RETURNING user_id, id, name, description, emoji, color, position, total_cards, fsrs_settings, archived_at, created_at, updated_at
`

type CreateNotebookParams struct {
	UserID       uuid.UUID   `json:"user_id"`
	Name         string      `json:"name"`
	Description  pgtype.Text `json:"description"`
	Emoji        pgtype.Text `json:"emoji"`
	Color        pgtype.Text `json:"color"`
	Position     interface{} `json:"position"`
	FsrsSettings []byte      `json:"fsrs_settings"`
}

// Note: fsrs_settings is always provided from Go code (source of truth for defaults)
func (q *Queries) CreateNotebook(ctx context.Context, arg CreateNotebookParams) (Notebook, error) {
	row := q.db.QueryRow(ctx, createNotebook,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Emoji,
		arg.Color,
		arg.Position,
		arg.FsrsSettings,
	)
	var i Notebook
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Emoji,
		&i.Color,
		&i.Position,
		&i.TotalCards,
		&i.FsrsSettings,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNotebook = `-- name: GetNotebook :one
SELECT user_id, id, name, description, emoji, color, position, total_cards, fsrs_settings, archived_at, created_at, updated_at FROM app.notebooks
WHERE user_id = $1 AND id = $2 AND archived_at IS NULL
`

type GetNotebookParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) GetNotebook(ctx context.Context, arg GetNotebookParams) (Notebook, error) {
	row := q.db.QueryRow(ctx, getNotebook, arg.UserID, arg.ID)
	var i Notebook
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Emoji,
		&i.Color,
		&i.Position,
		&i.TotalCards,
		&i.FsrsSettings,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isNotebookArchived = `-- name: IsNotebookArchived :one
SELECT EXISTS(SELECT 1 FROM app.notebooks n WHERE n.user_id = $1 AND n.id = $2) as exists,
       EXISTS(SELECT 1 FROM app.notebooks n WHERE n.user_id = $1 AND n.id = $2 AND n.archived_at IS NOT NULL) as is_archived
`

type IsNotebookArchivedParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

type IsNotebookArchivedRow struct {
	Exists     bool `json:"exists"`
	IsArchived bool `json:"is_archived"`
}

// Returns whether a notebook exists and its archived status.
// Used for idempotent archive operations.
func (q *Queries) IsNotebookArchived(ctx context.Context, arg IsNotebookArchivedParams) (IsNotebookArchivedRow, error) {
	row := q.db.QueryRow(ctx, isNotebookArchived, arg.UserID, arg.ID)
	var i IsNotebookArchivedRow
	err := row.Scan(&i.Exists, &i.IsArchived)
	return i, err
}

const listNotebooks = `-- name: ListNotebooks :many
SELECT user_id, id, name, description, emoji, color, position, total_cards, fsrs_settings, archived_at, created_at, updated_at FROM app.notebooks
WHERE user_id = $1 AND archived_at IS NULL
ORDER BY position ASC, created_at DESC
`

func (q *Queries) ListNotebooks(ctx context.Context, userID uuid.UUID) ([]Notebook, error) {
	rows, err := q.db.Query(ctx, listNotebooks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Notebook{}
	for rows.Next() {
		var i Notebook
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Emoji,
			&i.Color,
			&i.Position,
			&i.TotalCards,
			&i.FsrsSettings,
			&i.ArchivedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unarchiveNotebook = `-- name: UnarchiveNotebook :exec
UPDATE app.notebooks
SET archived_at = NULL
WHERE user_id = $1 AND id = $2 AND archived_at IS NOT NULL
`

type UnarchiveNotebookParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UnarchiveNotebook(ctx context.Context, arg UnarchiveNotebookParams) error {
	_, err := q.db.Exec(ctx, unarchiveNotebook, arg.UserID, arg.ID)
	return err
}

const updateNotebook = `-- name: UpdateNotebook :one
UPDATE app.notebooks
SET name = COALESCE($1, name),
    description = CASE
        WHEN $2::boolean THEN NULL
        ELSE COALESCE($3, description)
    END,
    emoji = CASE
        WHEN $4::boolean THEN NULL
        ELSE COALESCE($5, emoji)
    END,
    color = CASE
        WHEN $6::boolean THEN NULL
        ELSE COALESCE($7, color)
    END,
    position = COALESCE($8, position),
    fsrs_settings = CASE
        WHEN $9::boolean
        THEN jsonb_set(fsrs_settings, '{desired_retention}', to_jsonb($10::float8))
        ELSE fsrs_settings
    END
WHERE user_id = $11 AND id = $12 AND archived_at IS NULL
RETURNING user_id, id, name, description, emoji, color, position, total_cards, fsrs_settings, archived_at, created_at, updated_at
`

type UpdateNotebookParams struct {
	Name             pgtype.Text `json:"name"`
	ClearDescription bool        `json:"clear_description"`
	Description      pgtype.Text `json:"description"`
	ClearEmoji       bool        `json:"clear_emoji"`
	Emoji            pgtype.Text `json:"emoji"`
	ClearColor       bool        `json:"clear_color"`
	Color            pgtype.Text `json:"color"`
	Position         pgtype.Int4 `json:"position"`
	UpdateRetention  bool        `json:"update_retention"`
	DesiredRetention float64     `json:"desired_retention"`
	UserID           uuid.UUID   `json:"user_id"`
	ID               uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateNotebook(ctx context.Context, arg UpdateNotebookParams) (Notebook, error) {
	row := q.db.QueryRow(ctx, updateNotebook,
		arg.Name,
		arg.ClearDescription,
		arg.Description,
		arg.ClearEmoji,
		arg.Emoji,
		arg.ClearColor,
		arg.Color,
		arg.Position,
		arg.UpdateRetention,
		arg.DesiredRetention,
		arg.UserID,
		arg.ID,
	)
	var i Notebook
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Emoji,
		&i.Color,
		&i.Position,
		&i.TotalCards,
		&i.FsrsSettings,
		&i.ArchivedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
