// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: reviews.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPracticeCards = `-- name: CountPracticeCards :one
SELECT count(*) FROM app.cards
WHERE user_id = $1
  AND ($2::uuid IS NULL OR notebook_id = $2)
  AND suspended_at IS NULL
  AND buried_until IS NULL
`

type CountPracticeCardsParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	NotebookID pgtype.UUID `json:"notebook_id"`
}

func (q *Queries) CountPracticeCards(ctx context.Context, arg CountPracticeCardsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPracticeCards, arg.UserID, arg.NotebookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReview = `-- name: CreateReview :one
INSERT INTO app.reviews (
    user_id, id, card_id, notebook_id, fact_id, element_id,
    reviewed_at, rating, review_duration_ms, mode,
    state_before, stability_before, difficulty_before,
    elapsed_days, scheduled_days,
    state_after, stability_after, difficulty_after,
    interval_days, retrievability, undo_snapshot
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13,
    $14, $15,
    $16, $17, $18,
    $19, $20, $21
)
ON CONFLICT (user_id, id) DO NOTHING
RETURNING user_id, id, card_id, notebook_id, fact_id, element_id, reviewed_at, rating, review_duration_ms, mode, state_before, stability_before, difficulty_before, elapsed_days, scheduled_days, state_after, stability_after, difficulty_after, interval_days, retrievability, undo_snapshot, created_at
`

type CreateReviewParams struct {
	UserID           uuid.UUID     `json:"user_id"`
	ID               uuid.UUID     `json:"id"`
	CardID           pgtype.UUID   `json:"card_id"`
	NotebookID       uuid.UUID     `json:"notebook_id"`
	FactID           pgtype.UUID   `json:"fact_id"`
	ElementID        pgtype.Text   `json:"element_id"`
	ReviewedAt       time.Time     `json:"reviewed_at"`
	Rating           AppRating     `json:"rating"`
	ReviewDurationMs pgtype.Int4   `json:"review_duration_ms"`
	Mode             string        `json:"mode"`
	StateBefore      AppCardState  `json:"state_before"`
	StabilityBefore  pgtype.Float4 `json:"stability_before"`
	DifficultyBefore pgtype.Float4 `json:"difficulty_before"`
	ElapsedDays      float32       `json:"elapsed_days"`
	ScheduledDays    float32       `json:"scheduled_days"`
	StateAfter       AppCardState  `json:"state_after"`
	StabilityAfter   float32       `json:"stability_after"`
	DifficultyAfter  float32       `json:"difficulty_after"`
	IntervalDays     float32       `json:"interval_days"`
	Retrievability   pgtype.Float4 `json:"retrievability"`
	UndoSnapshot     []byte        `json:"undo_snapshot"`
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (AppReview, error) {
	row := q.db.QueryRow(ctx, createReview,
		arg.UserID,
		arg.ID,
		arg.CardID,
		arg.NotebookID,
		arg.FactID,
		arg.ElementID,
		arg.ReviewedAt,
		arg.Rating,
		arg.ReviewDurationMs,
		arg.Mode,
		arg.StateBefore,
		arg.StabilityBefore,
		arg.DifficultyBefore,
		arg.ElapsedDays,
		arg.ScheduledDays,
		arg.StateAfter,
		arg.StabilityAfter,
		arg.DifficultyAfter,
		arg.IntervalDays,
		arg.Retrievability,
		arg.UndoSnapshot,
	)
	var i AppReview
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.CardID,
		&i.NotebookID,
		&i.FactID,
		&i.ElementID,
		&i.ReviewedAt,
		&i.Rating,
		&i.ReviewDurationMs,
		&i.Mode,
		&i.StateBefore,
		&i.StabilityBefore,
		&i.DifficultyBefore,
		&i.ElapsedDays,
		&i.ScheduledDays,
		&i.StateAfter,
		&i.StabilityAfter,
		&i.DifficultyAfter,
		&i.IntervalDays,
		&i.Retrievability,
		&i.UndoSnapshot,
		&i.CreatedAt,
	)
	return i, err
}

const deleteReview = `-- name: DeleteReview :execrows
DELETE FROM app.reviews
WHERE user_id = $1 AND id = $2
`

type DeleteReviewParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

// Delete a review (for undo).
func (q *Queries) DeleteReview(ctx context.Context, arg DeleteReviewParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteReview, arg.UserID, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getCardForReview = `-- name: GetCardForReview :one
SELECT user_id, id, notebook_id, fact_id, element_id, state, stability, difficulty, step, due, last_review, elapsed_days, scheduled_days, reps, lapses, suspended_at, buried_until, created_at, updated_at FROM app.cards
WHERE user_id = $1 AND id = $2
FOR UPDATE
`

type GetCardForReviewParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) GetCardForReview(ctx context.Context, arg GetCardForReviewParams) (Card, error) {
	row := q.db.QueryRow(ctx, getCardForReview, arg.UserID, arg.ID)
	var i Card
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.NotebookID,
		&i.FactID,
		&i.ElementID,
		&i.State,
		&i.Stability,
		&i.Difficulty,
		&i.Step,
		&i.Due,
		&i.LastReview,
		&i.ElapsedDays,
		&i.ScheduledDays,
		&i.Reps,
		&i.Lapses,
		&i.SuspendedAt,
		&i.BuriedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestReviewForCard = `-- name: GetLatestReviewForCard :one
SELECT id FROM app.reviews
WHERE user_id = $1 AND card_id = $2
ORDER BY reviewed_at DESC
LIMIT 1
`

type GetLatestReviewForCardParams struct {
	UserID uuid.UUID   `json:"user_id"`
	CardID pgtype.UUID `json:"card_id"`
}

// Get the most recent review for a card to verify undo is for latest.
func (q *Queries) GetLatestReviewForCard(ctx context.Context, arg GetLatestReviewForCardParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getLatestReviewForCard, arg.UserID, arg.CardID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getPracticeCards = `-- name: GetPracticeCards :many
SELECT c.user_id, c.id, c.notebook_id, c.fact_id, c.element_id, c.state, c.stability, c.difficulty, c.step, c.due, c.last_review, c.elapsed_days, c.scheduled_days, c.reps, c.lapses, c.suspended_at, c.buried_until, c.created_at, c.updated_at, f.fact_type, f.content AS fact_content
FROM app.cards c
JOIN app.facts f ON f.user_id = c.user_id AND f.id = c.fact_id
WHERE c.user_id = $1
  AND ($2::uuid IS NULL OR c.notebook_id = $2)
  AND c.suspended_at IS NULL
  AND c.buried_until IS NULL
ORDER BY c.created_at ASC
LIMIT $4 OFFSET $3
`

type GetPracticeCardsParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	NotebookID pgtype.UUID `json:"notebook_id"`
	RowOffset  int32       `json:"row_offset"`
	RowLimit   int32       `json:"row_limit"`
}

type GetPracticeCardsRow struct {
	UserID        uuid.UUID          `json:"user_id"`
	ID            uuid.UUID          `json:"id"`
	NotebookID    uuid.UUID          `json:"notebook_id"`
	FactID        uuid.UUID          `json:"fact_id"`
	ElementID     string             `json:"element_id"`
	State         AppCardState       `json:"state"`
	Stability     pgtype.Float4      `json:"stability"`
	Difficulty    pgtype.Float4      `json:"difficulty"`
	Step          pgtype.Int2        `json:"step"`
	Due           pgtype.Timestamptz `json:"due"`
	LastReview    pgtype.Timestamptz `json:"last_review"`
	ElapsedDays   float32            `json:"elapsed_days"`
	ScheduledDays float32            `json:"scheduled_days"`
	Reps          int32              `json:"reps"`
	Lapses        int32              `json:"lapses"`
	SuspendedAt   pgtype.Timestamptz `json:"suspended_at"`
	BuriedUntil   pgtype.Date        `json:"buried_until"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	FactType      string             `json:"fact_type"`
	FactContent   []byte             `json:"fact_content"`
}

// Returns all non-suspended cards for practice mode (no due filter).
func (q *Queries) GetPracticeCards(ctx context.Context, arg GetPracticeCardsParams) ([]GetPracticeCardsRow, error) {
	rows, err := q.db.Query(ctx, getPracticeCards,
		arg.UserID,
		arg.NotebookID,
		arg.RowOffset,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPracticeCardsRow{}
	for rows.Next() {
		var i GetPracticeCardsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.NotebookID,
			&i.FactID,
			&i.ElementID,
			&i.State,
			&i.Stability,
			&i.Difficulty,
			&i.Step,
			&i.Due,
			&i.LastReview,
			&i.ElapsedDays,
			&i.ScheduledDays,
			&i.Reps,
			&i.Lapses,
			&i.SuspendedAt,
			&i.BuriedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FactType,
			&i.FactContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewByID = `-- name: GetReviewByID :one
SELECT user_id, id, card_id, notebook_id, fact_id, element_id, reviewed_at, rating, review_duration_ms, mode, state_before, stability_before, difficulty_before, elapsed_days, scheduled_days, state_after, stability_after, difficulty_after, interval_days, retrievability, undo_snapshot, created_at FROM app.reviews
WHERE user_id = $1 AND id = $2
`

type GetReviewByIDParams struct {
	UserID uuid.UUID `json:"user_id"`
	ID     uuid.UUID `json:"id"`
}

// Fetch a review for undo validation.
func (q *Queries) GetReviewByID(ctx context.Context, arg GetReviewByIDParams) (AppReview, error) {
	row := q.db.QueryRow(ctx, getReviewByID, arg.UserID, arg.ID)
	var i AppReview
	err := row.Scan(
		&i.UserID,
		&i.ID,
		&i.CardID,
		&i.NotebookID,
		&i.FactID,
		&i.ElementID,
		&i.ReviewedAt,
		&i.Rating,
		&i.ReviewDurationMs,
		&i.Mode,
		&i.StateBefore,
		&i.StabilityBefore,
		&i.DifficultyBefore,
		&i.ElapsedDays,
		&i.ScheduledDays,
		&i.StateAfter,
		&i.StabilityAfter,
		&i.DifficultyAfter,
		&i.IntervalDays,
		&i.Retrievability,
		&i.UndoSnapshot,
		&i.CreatedAt,
	)
	return i, err
}

const getStudyCards = `-- name: GetStudyCards :many
SELECT c.user_id, c.id, c.notebook_id, c.fact_id, c.element_id, c.state, c.stability, c.difficulty, c.step, c.due, c.last_review, c.elapsed_days, c.scheduled_days, c.reps, c.lapses, c.suspended_at, c.buried_until, c.created_at, c.updated_at, f.fact_type, f.content AS fact_content
FROM app.cards c
JOIN app.facts f ON f.user_id = c.user_id AND f.id = c.fact_id
WHERE c.user_id = $1
  AND ($2::uuid IS NULL OR c.notebook_id = $2)
  AND c.suspended_at IS NULL
  AND c.buried_until IS NULL
  AND (
    -- Due cards (overdue or currently in learning)
    (c.state != 'new' AND c.due <= now())
    OR
    -- New cards, subject to daily cap
    (c.state = 'new' AND (
      SELECT count(*) FROM app.reviews r
      WHERE r.user_id = $1
        AND r.state_before = 'new'
        AND r.mode = 'scheduled'
        AND r.reviewed_at >= date_trunc('day', now())
    ) < $3::bigint
    )
  )
ORDER BY
  -- Overdue non-new cards first
  CASE WHEN c.state != 'new' AND c.due <= now() THEN 0 ELSE 1 END,
  -- Then learning/relearning before new
  CASE WHEN c.state IN ('learning', 'relearning') THEN 0 ELSE 1 END,
  -- Within each group, earliest due first
  c.due ASC NULLS LAST,
  c.created_at ASC
LIMIT $4
`

type GetStudyCardsParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	NotebookID pgtype.UUID `json:"notebook_id"`
	NewCardCap int64       `json:"new_card_cap"`
	RowLimit   int32       `json:"row_limit"`
}

type GetStudyCardsRow struct {
	UserID        uuid.UUID          `json:"user_id"`
	ID            uuid.UUID          `json:"id"`
	NotebookID    uuid.UUID          `json:"notebook_id"`
	FactID        uuid.UUID          `json:"fact_id"`
	ElementID     string             `json:"element_id"`
	State         AppCardState       `json:"state"`
	Stability     pgtype.Float4      `json:"stability"`
	Difficulty    pgtype.Float4      `json:"difficulty"`
	Step          pgtype.Int2        `json:"step"`
	Due           pgtype.Timestamptz `json:"due"`
	LastReview    pgtype.Timestamptz `json:"last_review"`
	ElapsedDays   float32            `json:"elapsed_days"`
	ScheduledDays float32            `json:"scheduled_days"`
	Reps          int32              `json:"reps"`
	Lapses        int32              `json:"lapses"`
	SuspendedAt   pgtype.Timestamptz `json:"suspended_at"`
	BuriedUntil   pgtype.Date        `json:"buried_until"`
	CreatedAt     time.Time          `json:"created_at"`
	UpdatedAt     time.Time          `json:"updated_at"`
	FactType      string             `json:"fact_type"`
	FactContent   []byte             `json:"fact_content"`
}

// Returns due cards for review: overdue first, then learning, then new.
// New card cap limits how many new cards are introduced per day.
func (q *Queries) GetStudyCards(ctx context.Context, arg GetStudyCardsParams) ([]GetStudyCardsRow, error) {
	rows, err := q.db.Query(ctx, getStudyCards,
		arg.UserID,
		arg.NotebookID,
		arg.NewCardCap,
		arg.RowLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudyCardsRow{}
	for rows.Next() {
		var i GetStudyCardsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ID,
			&i.NotebookID,
			&i.FactID,
			&i.ElementID,
			&i.State,
			&i.Stability,
			&i.Difficulty,
			&i.Step,
			&i.Due,
			&i.LastReview,
			&i.ElapsedDays,
			&i.ScheduledDays,
			&i.Reps,
			&i.Lapses,
			&i.SuspendedAt,
			&i.BuriedUntil,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FactType,
			&i.FactContent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudyCountsByNotebook = `-- name: GetStudyCountsByNotebook :many
SELECT
    c.notebook_id,
    count(*) FILTER (WHERE c.state != 'new' AND c.due <= now()) AS due_count,
    count(*) FILTER (WHERE c.state = 'new') AS new_count
FROM app.cards c
WHERE c.user_id = $1
  AND c.suspended_at IS NULL
  AND c.buried_until IS NULL
  AND (
    (c.state != 'new' AND c.due <= now())
    OR c.state = 'new'
  )
GROUP BY c.notebook_id
`

type GetStudyCountsByNotebookRow struct {
	NotebookID uuid.UUID `json:"notebook_id"`
	DueCount   int64     `json:"due_count"`
	NewCount   int64     `json:"new_count"`
}

// Returns due card counts per notebook for the review launcher.
func (q *Queries) GetStudyCountsByNotebook(ctx context.Context, userID uuid.UUID) ([]GetStudyCountsByNotebookRow, error) {
	rows, err := q.db.Query(ctx, getStudyCountsByNotebook, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudyCountsByNotebookRow{}
	for rows.Next() {
		var i GetStudyCountsByNotebookRow
		if err := rows.Scan(&i.NotebookID, &i.DueCount, &i.NewCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreCardAfterUndo = `-- name: RestoreCardAfterUndo :exec
UPDATE app.cards SET
    state = $1,
    stability = $2,
    difficulty = $3,
    step = $4,
    due = $5,
    last_review = $6,
    elapsed_days = $7,
    scheduled_days = $8,
    reps = $9,
    lapses = $10
WHERE user_id = $11 AND id = $12
`

type RestoreCardAfterUndoParams struct {
	State         AppCardState       `json:"state"`
	Stability     pgtype.Float4      `json:"stability"`
	Difficulty    pgtype.Float4      `json:"difficulty"`
	Step          pgtype.Int2        `json:"step"`
	Due           pgtype.Timestamptz `json:"due"`
	LastReview    pgtype.Timestamptz `json:"last_review"`
	ElapsedDays   float32            `json:"elapsed_days"`
	ScheduledDays float32            `json:"scheduled_days"`
	Reps          int32              `json:"reps"`
	Lapses        int32              `json:"lapses"`
	UserID        uuid.UUID          `json:"user_id"`
	ID            uuid.UUID          `json:"id"`
}

// Restore card state from review's before columns + undo_snapshot.
// undo_snapshot contains: step, due, last_review, reps, lapses
func (q *Queries) RestoreCardAfterUndo(ctx context.Context, arg RestoreCardAfterUndoParams) error {
	_, err := q.db.Exec(ctx, restoreCardAfterUndo,
		arg.State,
		arg.Stability,
		arg.Difficulty,
		arg.Step,
		arg.Due,
		arg.LastReview,
		arg.ElapsedDays,
		arg.ScheduledDays,
		arg.Reps,
		arg.Lapses,
		arg.UserID,
		arg.ID,
	)
	return err
}

const updateCardAfterReview = `-- name: UpdateCardAfterReview :exec
UPDATE app.cards SET
    state = $1,
    stability = $2,
    difficulty = $3,
    step = $4,
    due = $5,
    last_review = $6,
    elapsed_days = $7,
    scheduled_days = $8,
    reps = reps + 1,
    lapses = CASE WHEN $9::bool THEN lapses + 1 ELSE lapses END
WHERE user_id = $10 AND id = $11
`

type UpdateCardAfterReviewParams struct {
	State         AppCardState       `json:"state"`
	Stability     pgtype.Float4      `json:"stability"`
	Difficulty    pgtype.Float4      `json:"difficulty"`
	Step          pgtype.Int2        `json:"step"`
	Due           pgtype.Timestamptz `json:"due"`
	LastReview    pgtype.Timestamptz `json:"last_review"`
	ElapsedDays   float32            `json:"elapsed_days"`
	ScheduledDays float32            `json:"scheduled_days"`
	AddLapse      bool               `json:"add_lapse"`
	UserID        uuid.UUID          `json:"user_id"`
	ID            uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateCardAfterReview(ctx context.Context, arg UpdateCardAfterReviewParams) error {
	_, err := q.db.Exec(ctx, updateCardAfterReview,
		arg.State,
		arg.Stability,
		arg.Difficulty,
		arg.Step,
		arg.Due,
		arg.LastReview,
		arg.ElapsedDays,
		arg.ScheduledDays,
		arg.AddLapse,
		arg.UserID,
		arg.ID,
	)
	return err
}
